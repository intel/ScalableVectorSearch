# Copyright 2025 Intel Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

if(svs_microarch_cmake_included)
    return()
endif()
set(svs_microarch_cmake_included true)

# N.B.: first microarch listed in targets file is treated as "base" microarch
# which is used to build base object files, shared libs and executables
if(CMAKE_SYSTEM_PROCESSOR MATCHES "x86_64")
    file(STRINGS "${CMAKE_CURRENT_LIST_DIR}/microarch_targets_x86_64" SVS_MICROARCHS)
elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64" OR CMAKE_SYSTEM_PROCESSOR MATCHES "arm64")
    if(APPLE)
        file(STRINGS "${CMAKE_CURRENT_LIST_DIR}/microarch_targets_aarch64_darwin" SVS_MICROARCHS)
    else()
        file(STRINGS "${CMAKE_CURRENT_LIST_DIR}/microarch_targets_aarch64" SVS_MICROARCHS)
    endif()
else()
    message(FATAL_ERROR "Unknown CMAKE_SYSTEM_PROCESSOR: ${CMAKE_SYSTEM_PROCESSOR}")
endif()


# Try to find the Python executable.
#
# If it's given as part of the Cmake arguments given by "scikit build", then use that.
# Otherwise, fall back to using plain old "python".
# If *THAT* doesn't work, give up.
if(DEFINED PYTHON_EXECUTABLE)
    set(SVS_PYTHON_EXECUTABLE "${PYTHON_EXECUTABLE}")
else()
    set(SVS_PYTHON_EXECUTABLE "python")
endif()

# Run the python script to get optimization flags for the desired back-ends.
#
# FLAGS_SCRIPT - Path to the Python script that will take the compiler, compiler version,
#   and list of desired microarchitectures and generate optimization flags for each
#   microarchitecture.
#
# FLAGS_TEXT_FILE - List of optimization flags for each architecture.
#   Expected format:
#       -march=arch1,-mtune=arch1
#       -march=arch2,-mtune=arch2
#       ...
#       -march=archN,-mtune=archN
#
#   The number of lines should be equal to the number of microarchitectures.
#   NOTE: The entries within each line are separated by a comma on purpose to allow CMake
#   to read the whole file as a List and then use string replacement on the commas to turn
#   each line into a list in its own right.
#

#####
##### Generate optimization flags for the given microarchitectures.
#####

set(FLAGS_SCRIPT "${CMAKE_CURRENT_LIST_DIR}/scripts/microarch.py")
set(FLAGS_TEXT_FILE "${CMAKE_CURRENT_BINARY_DIR}/optimization_flags.txt")

execute_process(
    COMMAND
        ${SVS_PYTHON_EXECUTABLE}
        ${FLAGS_SCRIPT}
        ${FLAGS_TEXT_FILE}
        --compiler ${CMAKE_CXX_COMPILER_ID}
        --compiler-version ${CMAKE_CXX_COMPILER_VERSION}
        --microarchitectures ${SVS_MICROARCHS}
    COMMAND_ERROR_IS_FATAL ANY
)

file(STRINGS "${FLAGS_TEXT_FILE}" OPTIMIZATION_FLAGS)
message("Flags: ${OPTIMIZATION_FLAGS}")
list(LENGTH OPTIMIZATION_FLAGS OPT_FLAGS_LENGTH)
message("Length of flags: ${OPT_FLAGS_LENGTH}")

#####
##### Generate instantiations for each microarch.
#####

# Path to the Python generator script
set(SVS_GENERATOR_SCRIPT "${CMAKE_CURRENT_LIST_DIR}/scripts/generate_microarch_source_files.py")

# Output directory inside the build tree
set(SVS_GENERATED_DIR "${CMAKE_BINARY_DIR}/generated")
file(MAKE_DIRECTORY ${SVS_GENERATED_DIR})

# Define which files will be generated by the script
set(SVS_GENERATED_HEADER "${SVS_GENERATED_DIR}/distance_instantiations.h")
set(SVS_GENERATED_SOURCES)
foreach(MICROARCH ${SVS_MICROARCHS})
    list(APPEND SVS_GENERATED_SOURCES "${SVS_GENERATED_DIR}/microarch_${MICROARCH}.cpp")
endforeach()

# Generate sources
execute_process(
    COMMAND ${SVS_PYTHON_EXECUTABLE} ${SVS_GENERATOR_SCRIPT} ${SVS_GENERATED_DIR}
    RESULT_VARIABLE GEN_RESULT
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    ERROR_VARIABLE GEN_ERROR
)

if(NOT GEN_RESULT EQUAL 0)
    message(FATAL_ERROR "Failed to generate distance instantiations:\n${GEN_ERROR}")
endif()

# Group the generated sources into a dummy custom target so they are rerun if missing
add_custom_target(svs_generate_distance_instantiations
    DEPENDS ${SVS_GENERATED_HEADER} ${SVS_GENERATED_SOURCES}
)

# Include the generated header
include_directories(${SVS_GENERATED_DIR})


#####
##### Helper targets to support required microarchs and apply relevant compiler optimizations.
#####

# Create base meta-target to collect common defines
add_library(svs_microarch_options_base INTERFACE)
add_library(svs::microarch_options_base ALIAS svs_microarch_options_base)

# Add support and compiled defines to base target
foreach(MICROARCH IN LISTS SVS_MICROARCHS)
    target_compile_options(svs_microarch_options_base INTERFACE
        -DSVS_MICROARCH_SUPPORT_${MICROARCH}
        -DSVS_MICROARCH_COMPILED_${MICROARCH}
    )
endforeach()

# Add per-microarch optimization targets
foreach(MICROARCH OPT_FLAGS IN ZIP_LISTS SVS_MICROARCHS OPTIMIZATION_FLAGS)
    string(REPLACE "," ";" OPT_FLAGS ${OPT_FLAGS})

    add_library(svs_microarch_options_${MICROARCH} INTERFACE)
    add_library(svs::microarch_options_${MICROARCH} ALIAS svs_microarch_options_${MICROARCH})
    target_compile_options(svs_microarch_options_${MICROARCH} INTERFACE
        ${OPT_FLAGS}
        -DSVS_TARGET_MICROARCH=${MICROARCH}
        -DSVS_MICROARCH_COMPILED_${MICROARCH}
    )
endforeach()

function(create_microarch_instantiations)
    set(MICROARCH_OBJECT_FILES "")
    foreach(MICROARCH OPT_FLAGS IN ZIP_LISTS SVS_MICROARCHS OPTIMIZATION_FLAGS)
        set(OBJ_NAME "microarch_${MICROARCH}")
        set(SRC_FILE "${SVS_GENERATED_DIR}/microarch_${MICROARCH}.cpp")

        if(NOT EXISTS "${SRC_FILE}")
            message(FATAL_ERROR "Missing source file for microarch: ${SRC_FILE}")
        endif()

        add_library(${OBJ_NAME} OBJECT ${SRC_FILE})
        target_link_libraries(${OBJ_NAME}
            PRIVATE ${SVS_LIB} svs::compile_options fmt::fmt svs_microarch_options_${MICROARCH}
        )

        list(APPEND MICROARCH_OBJECT_FILES $<TARGET_OBJECTS:${OBJ_NAME}>)
    endforeach()

    set(MICROARCH_OBJECT_FILES "${MICROARCH_OBJECT_FILES}" PARENT_SCOPE)
endfunction()