/*
 * Copyright 2023 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "svs/concepts/data.h"
#include "svs/core/data/io.h"
#include "svs/core/data/simple.h"
#include "svs/core/data/view.h"
#include "svs/lib/datatype.h"
#include "svs/lib/dispatcher.h"
#include "svs/lib/saveload.h"

// third-party
#include "fmt/std.h"

// stl
#include <filesystem>
#include <optional>

namespace svs {

template <typename T, size_t Extent = Dynamic>
data::SimpleData<T, Extent> load_data(const std::filesystem::path& path) {
    return data::SimpleData<T, Extent>::load(path);
}

// Forward Declaration
template <typename T, size_t Dims, typename Alloc> class VectorDataLoader;

template <typename Allocator = HugepageAllocator<std::byte>>
struct UnspecializedVectorDataLoader {
    template <typename T> using rebind_alloc = lib::rebind_allocator_t<T, Allocator>;

    UnspecializedVectorDataLoader() = default;
    UnspecializedVectorDataLoader(
        const std::filesystem::path& path,
        std::optional<DataType> type = std::nullopt,
        std::optional<size_t> dims = std::nullopt,
        const Allocator& allocator = {}
    )
        : path_{path}
        , allocator_{allocator} {
        // If deduction is not needed, then just copy over the provided values.
        if (type && dims) {
            type_ = type.value();
            dims_ = dims.value();
            return;
        }

        // Otherwise, we need to perform deduction.
        auto matcher = lib::load_from_disk<data::Matcher>(
            path_, type.value_or(svs::DataType::undef), dims.value_or(Dynamic)
        );
        type_ = type.value_or(matcher.eltype);
        dims_ = dims.value_or(matcher.dims);
    }

    // Refine into a fully specialized ``VectorDataLoader``.
    template <typename T, size_t Dims = Dynamic>
    VectorDataLoader<T, Dims, rebind_alloc<T>>
    refine(lib::Type<T> SVS_UNUSED(type), lib::Val<Dims> SVS_UNUSED(dims) = {}) const {
        using Other = rebind_alloc<T>;
        return VectorDataLoader<T, Dims, Other>{*this};
    }

    ///// Members
    // The path to the source file.
    std::filesystem::path path_;
    // The uncompressed data type.
    DataType type_ = DataType::undef;
    size_t dims_ = Dynamic;
    Allocator allocator_ = {};
};

///
/// @brief Loader for uncompressed vector datasets.
///
/// @tparam T The element type of the encoded vectors.
///     Typically, this will be a floating point type like ``float`` or ``svs::Float16``
///     but may be an integer type as well for certain datsets.
/// @tparam Extent The compile-time dimensionality of the vectors to be read.
///     May provide a performance boost if given. Default: ``svs::Dynamic``.
/// @tparam Allocator The allocator to use for the memory backing the data when loaded.
///
template <typename T, size_t Extent = Dynamic, typename Allocator = HugepageAllocator<T>>
class VectorDataLoader {
  public:
    /// @brief The full type of the loaded dataset.
    using return_type = data::SimpleData<T, Extent, Allocator>;

    ////// Constructors

    ///
    /// @brief Construct a new VectorDataLoader.
    ///
    /// @param path The path to the dataset on disk. See detailed notes.
    /// @param allocator The allocator to be used.
    ///
    /// Typically, ``path`` should point to a directory generated by one of the index
    /// save methods. This will provide the most error checking. However, the path can
    /// also point directly to the following files:
    ///
    /// * Any "*.svs" file, which is the native file path used by the SVS library.
    /// * Any "[f/b/i]vecs" file typically used by similarity search libraries.
    ///
    VectorDataLoader(const std::filesystem::path& path, const Allocator& allocator)
        : path_{path}
        , allocator_{allocator} {}

    explicit VectorDataLoader(const std::filesystem::path& path)
        : path_{path} {}

    template <typename Other>
    VectorDataLoader(const UnspecializedVectorDataLoader<Other>& other)
        : VectorDataLoader{other.path_, other.allocator_} {
        // Validate the refinement.
        if (datatype_v<T> != other.type_) {
            throw ANNEXCEPTION("Type mismatch!");
        }

        if constexpr (Extent != Dynamic) {
            auto other_dims = other.dims_;
            if (other_dims != Dynamic && other_dims != Extent) {
                throw ANNEXCEPTION("Dims mismatch!");
            }
        }
    }

    /// @brief Load the dataset from disk.
    return_type load() const { return return_type::load(path_, allocator_); }

    /// @brief Return the file path given when this class was constructed.
    const std::filesystem::path& get_path() const { return path_; }

    ///// Members
    std::filesystem::path path_ = {};
    Allocator allocator_ = {};
};

// Matching rule for uncompressed data.
namespace data::detail {
template <typename T, size_t Extent> int64_t check_match(svs::DataType type, size_t dims) {
    // If the types don't match - then there is no match.
    if (type != svs::datatype_v<T>) {
        return lib::invalid_match;
    }

    // This handles both the case where ``Extent`` is static and dims match, or ``Extent``
    // is Dynamic and the requested dims are dynamic.
    if (dims == Extent) {
        return lib::perfect_match;
    }

    // Otherwise, if there is a static mismatch in dimensions, we can't match.
    if constexpr (Extent == Dynamic) {
        return lib::imperfect_match;
    }
    return lib::invalid_match;
}
} // namespace data::detail

// TODO: Further constrain allocator to be rebind-convertible
template <typename T, size_t Extent, typename Alloc1, typename Alloc2>
struct lib::DispatchConverter<
    UnspecializedVectorDataLoader<Alloc1>,
    VectorDataLoader<T, Extent, Alloc2>> {
    static int64_t match(const UnspecializedVectorDataLoader<Alloc1>& loader) {
        return data::detail::check_match<T, Extent>(loader.type_, loader.dims_);
    }

    static VectorDataLoader<T, Extent, Alloc2>
    convert(const UnspecializedVectorDataLoader<Alloc1>& loader) {
        return loader.template refine<T, Extent>(lib::Type<T>());
    }

    static std::string description() {
        if constexpr (Extent == Dynamic) {
            auto t = datatype_v<T>;
            return fmt::format(
                "VectorDataLoader with element type {} and any dimension", t
            );
        } else {
            return fmt::format(
                "VectorDataLoader with element type {} and {} dimensions",
                datatype_v<T>,
                Extent
            );
        }
    }
};

} // namespace svs
